<!--
        DTD to define an XML variety to generate DDL for creating
        storage objects (be it tables in an sql db or dd objects)

        The DTD is based on the propel XML database DTD which in turn was
        based on the apache torque DTD. We keep a *very strict* log of
        our changes. The propel framework has bits and pieces of code we
        can reuse, and every deviation from their schema will induce a code
        change.

        The initial goals are:
        1. to create an absolute minimal DTD to replace xartableddl and xardatadict
        2. stay compatible with the original DTD it was based on.
        3. be able to generate more structured schema's from the DTD (like RNG)
        4. be able to produce the xml from the database itself.

        Initial xarddl.dtd was based on:
            Propel XML database schema DTD
            $Id: database.dtd,v 1.7 2005/03/30 11:38:18 hlellelid Exp $
        Changelog in applied order (meaning, if you make a change, add to the bottom):
        * removed element 'reference'            - used in 'foreign-key' to specify references
        * removed element 'foreign-key'      - to define foreign key relationships
        * removed element 'rule'                    - to define validation rules
        * removed element 'validator'     - grouped rule elements
        * removed element 'vendor'        - used for vendor specific definitions in xml
        * removed element 'inheritance'      - used for linking code classes to the columns
        * removed element 'parameter'     - used as child of the vendor element to define parameters
        * removed element 'id-method-parameter' - used to customize id generation
        * removed attribute defaultPHPNameingMethod from 'database' element (including referencing comments)
        * removed attribute heavyIndexing from 'database'+'column' element
        * removed attribute baseClass from 'database'+'column' element
        * removed attribute basePeer from 'database'+'column' element
        * removed attribute defaultIdMethod from 'database' element
        * removed attribute defaultTranslateMethode (with e?) from 'database' element
        * removed phpName, ideMethod, skipSql, readOnly, abstract, isTree, interface, phpNamingMethod attributes from 'table' element
        * removed phpName, peerName, phpType, inheritance, inputValidator, phpNamingMethod, lazyload attributes from 'column' element
        * where no child definitions were left due to removals, declared elements EMPTY
        * removed element 'external-schema'
        * removed 'alias' attribute from 'table' element
        * removed 'package' attribute from 'database'+'table' elements
        * removed PHP_OBJECT, DISTINCT, STRUCT, ARRAY, REF, NULL from values for 'type' attribute for 'column' element
        * consolidated 'unique' and 'index' into 'index type="unique"'
        * removed elements 'unique' and 'unique-column'
        * added definition for 'primary' element.
        * removed attribute 'primaryKey' from 'column' element
        * removed element 'index-column', replaced it with 'column' to sync it up with 'primary' definition
        * rename element 'database' to 'schema' as that is more accurate
        * made attribute 'description' apply to schema, table and column
        * changed autoIncrement to autoincrement (all lower case)
        * made 'name' attributes of type NMTOKEN
        * change 'name' attribute of 'table' element to ID
        * made 'primary' a required sub of 'table', as a consequence, 'table' itself can have 0 or more 'column' tags
        * replaced the description attribute on some with a child 'description' tag of all.
        * lowercasing attribute values of column.type
        * added id attribute to all tags (use more common entity syntax to describe it, later on)
-->

<!--
  Define some common things and some stuff we may want to define more
  clearly later on. A dtd has not got a strong notion of types, so we
  need to help it a little
-->
<!ENTITY % common "id    ID    #IMPLIED
                   xmlns CDATA #FIXED 'http://xaraya.com/2007/schema'">
<!ENTITY % boolean        "(true|false)">
<!ENTITY % positiveNumber "NMTOKEN">

<!--
  Element:
    schema    -  root element for the schema ddl xml format
  Attributes:
    name      -  optional name of the schema. If schema's are used in the physical database,
                 this name can be used to enclose the specified xml schema into the physical schema.
-->
<!ELEMENT schema (table+,description?)>
<!ATTLIST schema
  %common;
  name NMTOKEN #IMPLIED
>

<!--
  Element:
    description   - give a, possibly lengthy, description of the surrounding element. The intention
                    is to be able to embed other xml markup languages in this elements
                    children (xhtml for example) so it lends itself for rich documentation
  Attributes:
-->
<!ATTLIST description  %common;>

<!--
  Element:
    table     -   a data table, be that physical, logical, dynamic or virtual. The generator and
                  the framework in which that live is free to generate its table types of choice.
  Attributes:
    name      -   required name of this table, each table in a schema needs to have a unique name
                  as such we let this attribute comply to the ID production. That is too much, but safe.
-->
<!ELEMENT table (primary,column*,index*,description?)>
<!ATTLIST table
  %common;
  name ID #REQUIRED
>

<!--
  Element:
    number    - a number of any format
  Attributes:
    size      - required positive number indicating the number of positions in the number (before the decimal point, if any)
    min       - the minimum value of the number, default:  none
    max       - the maximum value of the number, default:  none
    decimals  - number of positions behind the decimal comma, default 0
-->
<!ELEMENT number EMPTY>
<!ATTLIST number
  %common;
  size     %positiveNumber #REQUIRED;
  min      NMTOKEN
  max      NMTOKEN
  decimals NMTOKEN
>

<!--
  Element:
    text      - element describing a textual datatype
  Attributes:
    size      - required positive number indicating the number of characters in the text
-->
<!ELEMTN text #EMPTY>
<!ATTLIST
  %common;
  size    %positiveNumber; #REQUIRED
>

<!--
  Element:
    boolean   - element describing a logical truth value
  Attributes:
-->
<!ELEMENT boolean EMPTY>
<!ATTLIST boolean %common;>


<!--
  primary element
  @todo reformulate as constraint
-->
<!ELEMENT primary (column+)>
<!ATTLIST primary  %common;>


<!--
  The date datatype
  @todo size means what exactly here?
-->
<!ELEMENT date EMPTY>
<!ATTLIST date
  %common;
  size      %positiveNumber;
>

<!--
  Element:
    column    - a column in a data table. This element itself describes just
                the characteristics of it being a column in the data table, it
                should not describe properties of the value which will be stored
                in that column. The different datatype elements are used for that.
  Attributes:
    name      - required name of the column
    required  - does the value of this column need to be present, in other words is the 'non-value' NULL allowed?
    auto      - automatically generate the value of this column; what this actually means, depends on the datatype


  @todo an attribute 'optimze' with values like 'speed','size' etc. could make sense
  @todo definition of the 'auto' attribute it pretty 'thin'
              = autoincrement for number
              = timestamp for date
              = text?
        we can also use a default attribute, which we probably need anyways
    -->

-->
<!ELEMENT column (description?,(number|date|boolean|text|binary))>
<!ATTLIST column
  %common;
  name NMTOKEN #REQUIRED
  required %boolean; "false"
  auto     %boolean; "false"
  default  CDATA #IMPLIED
  scale CDATA #IMPLIED
>

<!--
  index element
  @todo reformulate as constraint?
-->
<!ELEMENT index (column+,description?)>
<!ATTLIST index
  %common;
  name NMTOKEN #IMPLIED
  type (default|unique) "default"
>

<!--
    Wishes:
    * the 'type' attribute for the 'column' element should only designate an
    'abstract' type, not related  to the database types like TINYINT or something.
    The storage types used by different databases can be figured out by the
    generator in combination with other information supplied in the xml.
    This is basically what creole does, but the mapping they use is a set of
    types (JDBC types actually) which are still close to the actual type of the
    database. Since this code is in place, we might as well use it.

    Example set of more abstract types:
    - char | binary | number | boolean | date | time
    Ideally these would be children of the 'column' element so the attributes
    can be defined on them specifically (e.g. 'precision' which only makes sense for numbers and perhaps time)

    * scale attribute is confusing, i'd rather use 'precision' or 'decimals' (also see previous point)

    * think about constraints, both on column and table level, they fit in nicely as
    children of the 'column' or 'table' elements.

    * [DONE] the mixed case use of 'autoIncrement' is not needed, lead
    to confusion only

    * [DONE] the elements 'index' and 'unique' are the same, index type='unique' would
    be better imo. Similarly, unique-column and index-column are then redundant, either
    to be replaced by just a 'index-column' element, or <column name="colname"/> to reference
    a column in the table definition.

    * [DONE] an element 'primary' as a grouper around the 'column' element would be nice
    Example:
    <table name="test">
        <column name="normal" type="INTEGER" size="4"/>
        <primary>
            <column name="ref_name" type="INTEGER" size="10"/>
            <column name="ref1_name" type="INTEGER" size="10"/>
        </primary>
    </table>

    * Primary keys are either automatically indexed, or should always be indexed, the
    generator can take this into account. Some databases may do this automatically, either
    explicit or implicit.

    * [DONE] an 'id' attribute on all tags supported.

    * vendor parameters *are* useful, add them back at some point, but only if
    we implement right away the support of those parameters (i.e. not only do the
    familiar mysql table type stuff, but also other parameters)

    * xaraya doesnt use foreign keys yet, doesnt mean we cant have support in the
    schema for it though.
    Example of how this could look:
      <table name="test">
          <column name="normal" type="INTEGER" size="4"/>
          <primary>
              <column name="ref_name" type="INTEGER" size="10"/>
              <column name="ref1_name" type="INTEGER" size="10"/>
          </primary>
          <foreign remote="other_table" ondelete="(cascade|restrict|setnull|none)" onupdate="(cascade|restrict|setnull|none)">
              <reference local="ref_name" remote="other_columns_name"/>
          </foreign>
      </table>
    ondelete means: what happens to the local record if the remote record gets deleted.
    onupdate means: what happens to the local columns if the remote columns get updated.
    If a foreign key is composite, add more <reference/> elements.

    * other than the precise size="14" it could be comfortable to specify 'qualitative' sizes.
    For example:
        small      64K  'c64'       'amoebe'
        medium      1M  'pda'       'fly'
        large      16M  'notebook'  'dog'
        long      256M  'laptop'    'ape'
        huge        4G  'desktop'   'human'
    where the generator translates
    this into something for the backend that fits. The second column would be
    comfortable from a developer perspective without having to know what column
    type it actually translates into, it guarantees to be capable of storing the
    specified size (at minimum)

    * I dont like the capital attribute values for 'type'
-->