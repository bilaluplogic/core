<?xml version="1.0" encoding="UTF-8"?>
<!--
  DTD to define an XML variety to generate DDL for creating
  storage objects (be it tables in an sql db or dd objects)
  
  The DTD is based on the propel XML database DTD which in turn was
  based on the apache torque DTD. We keep a *very strict* log of
  our changes. The propel framework has bits and pieces of code we
  can reuse, and every deviation from their schema will induce a code
  change.
  
  The initial goals are:
  1. to create an absolute minimal DTD to replace xartableddl and xardatadict
  2. stay compatible with the original DTD it was based on.
  3. be able to generate more structured schema's from the DTD (like RNG)
  4. be able to produce the xml from the database itself.
  
  Initial xarddl.dtd was based on:
      Propel XML database schema DTD
      $Id: database.dtd,v 1.7 2005/03/30 11:38:18 hlellelid Exp $
  Changelog in applied order (meaning, if you make a change, add to the bottom):
  * removed element 'reference'            - used in 'foreign-key' to specify references
  * removed element 'foreign-key'      - to define foreign key relationships
  * removed element 'rule'                    - to define validation rules
  * removed element 'validator'     - grouped rule elements
  * removed element 'vendor'        - used for vendor specific definitions in xml
  * removed element 'inheritance'      - used for linking code classes to the columns
  * removed element 'parameter'     - used as child of the vendor element to define parameters
  * removed element 'id-method-parameter' - used to customize id generation
  * removed attribute defaultPHPNameingMethod from 'database' element (including referencing comments)
  * removed attribute heavyIndexing from 'database'+'column' element
  * removed attribute baseClass from 'database'+'column' element
  * removed attribute basePeer from 'database'+'column' element
  * removed attribute defaultIdMethod from 'database' element
  * removed attribute defaultTranslateMethode (with e?) from 'database' element
  * removed phpName, ideMethod, skipSql, readOnly, abstract, isTree, interface, phpNamingMethod attributes from 'table' element
  * removed phpName, peerName, phpType, inheritance, inputValidator, phpNamingMethod, lazyload attributes from 'column' element
  * where no child definitions were left due to removals, declared elements EMPTY
  * removed element 'external-schema'
  * removed 'alias' attribute from 'table' element
  * removed 'package' attribute from 'database'+'table' elements
  * removed PHP_OBJECT, DISTINCT, STRUCT, ARRAY, REF, NULL from values for 'type' attribute for 'column' element
  * consolidated 'unique' and 'index' into 'index type="unique"'
  * removed elements 'unique' and 'unique-column'
  * added definition for 'primary' element.
  * removed attribute 'primaryKey' from 'column' element
  * removed element 'index-column', replaced it with 'column' to sync it up with 'primary' definition
  * rename element 'database' to 'schema' as that is more accurate
  * made attribute 'description' apply to schema, table and column
  * changed autoIncrement to autoincrement (all lower case)
  * made 'name' attributes of type CDATA
  * change 'name' attribute of 'table' element to ID
  * made 'primary' a required sub of 'table', as a consequence, 'table' itself can have 0 or more 'column' tags
  * replaced the description attribute on some with a child 'description' tag of all.
  * lowercasing attribute values of column.type
  * added id attribute to all tags (use more common entity syntax to describe it, later on)
  
  June 2007 DECISION: we break compatibility with the original DTDs
-->
<!--
  Define some common things and some stuff we may want to define more
  clearly later on. A dtd has not got a strong notion of types, so we
  need to help it a little
-->
<grammar xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0" ns="http://xaraya.com/2007/schema" xmlns="http://relaxng.org/ns/structure/1.0" datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes">
  <define name="common">
    <optional>
      <attribute name="id">
        <data type="ID"/>
      </attribute>
    </optional>
  </define>
  <!-- Entities corresponding to the values for the datatypes -->
  <define name="textValue">
    <data type="string" datatypeLibrary=""/>
  </define>
  <define name="binaryValue">
    <data type="string" datatypeLibrary=""/>
  </define>
  <!-- CDATA? then we need an encoding -->
  <define name="booleanValue">
    <choice>
      <value>true</value>
      <value>false</value>
    </choice>
  </define>
  <define name="timeValue">
    <data type="string" datatypeLibrary=""/>
  </define>
  <define name="numberValue">
    <data type="string" datatypeLibrary=""/>
  </define>
  <!-- Helpers for the specification of attributes -->
  <define name="anyInteger">
    <data type="string" datatypeLibrary=""/>
  </define>
  <define name="sizeSpec">
    <data type="string" datatypeLibrary=""/>
  </define>
  <!--
    Element:
      schema    -  root element for the schema ddl xml format
    Attributes:
      name      -  optional name of the schema. If schema's are used in the physical database,
                   this name can be used to enclose the specified xml schema into the physical schema.
  -->
  <define name="schema">
    <element name="schema">
      <ref name="attlist.schema"/>
      <oneOrMore>
        <ref name="table"/>
      </oneOrMore>
      <optional>
        <ref name="description"/>
      </optional>
    </element>
  </define>
  <define name="attlist.schema" combine="interleave">
    <ref name="common"/>
    <optional>
      <attribute name="name"/>
    </optional>
  </define>
  <!--
    Element:
      description   - give a, possibly lengthy, description of the surrounding element. The intention
                      is to be able to embed other xml markup languages in this elements
                      children (xhtml for example) so it lends itself for rich documentation
  -->
  <define name="description">
    <element name="description">
      <ref name="attlist.description"/>
      <text/>
    </element>
  </define>
  <define name="attlist.description" combine="interleave">
    <ref name="common"/>
  </define>
  <!--
    Element:
      table     -   a data table, be that physical, logical, dynamic or virtual. The generator and
                    the framework in which that live is free to generate its table types of choice.
    Attributes:
      name      -   required name of this table, each table in a schema needs to have a unique name
                    as such we let this attribute comply to the ID production. That is too much, but safe.
  -->
  <define name="table">
    <element name="table">
      <ref name="attlist.table"/>
      <ref name="primary"/>
      <zeroOrMore>
        <ref name="column"/>
      </zeroOrMore>
      <zeroOrMore>
        <ref name="index"/>
      </zeroOrMore>
      <optional>
        <ref name="description"/>
      </optional>
    </element>
  </define>
  <define name="attlist.table" combine="interleave">
    <ref name="common"/>
    <attribute name="name">
      <data type="ID"/>
    </attribute>
  </define>
  <!--
    Element:
      column    - a column in a data table. This element itself describes just
                  the characteristics of it being a column in the data table, it
                  should not describe properties of the value which will be stored
                  in that column. The different datatype elements are used for that.
    Attributes:
      name      - required name of the column
      required  - does the value of this column need to be present, in other words is the 'non-value' NULL allowed?
      auto      - automatically generate the value of this column; what this actually means, depends on the data type used in the column
    
    
    @todo an attribute 'optimze' with values like 'speed','size' etc. could make sense
    @todo definition of the 'auto' attribute it pretty 'thin'
                = autoincrement for number
                = timestamp for date
                = text?
          we can also use a default attribute, which we probably need anyways
  -->
  <define name="column">
    <element name="column">
      <ref name="attlist.column"/>
      <optional>
        <ref name="description"/>
      </optional>
      <choice>
        <ref name="number"/>
        <ref name="time"/>
        <ref name="boolean"/>
        <ref name="text"/>
        <ref name="binary"/>
      </choice>
    </element>
  </define>
  <define name="attlist.column" combine="interleave">
    <ref name="common"/>
    <attribute name="name"/>
    <optional>
      <attribute name="required" a:defaultValue="false">
        <ref name="booleanValue"/>
      </attribute>
    </optional>
    <optional>
      <attribute name="auto" a:defaultValue="false">
        <ref name="booleanValue"/>
      </attribute>
    </optional>
  </define>
  <!--
    Element:
      number    - a number of any format
    Attributes:
      default   - default value
      size      - required positive number indicating the number of positions in the number (before the decimal point, if any)
      min       - the minimum value of the number, default:  none
      max       - the maximum value of the number, default:  none
      decimals  - number of positions behind the decimal comma, default 0
    @todo figure out a way to specify big and small numbers like 1.000.000.000.000 (perhaps just use the scientific notation 1E12 ?)
    @todo base default 10 ?
  -->
  <define name="number">
    <element name="number">
      <ref name="attlist.number"/>
      <empty/>
    </element>
  </define>
  <define name="attlist.number" combine="interleave">
    <ref name="common"/>
    <optional>
      <attribute name="default">
        <ref name="numberValue"/>
      </attribute>
    </optional>
    <optional>
      <attribute name="min">
        <ref name="numberValue"/>
      </attribute>
    </optional>
    <optional>
      <attribute name="max">
        <ref name="numberValue"/>
      </attribute>
    </optional>
    <attribute name="size">
      <ref name="sizeSpec"/>
    </attribute>
    <optional>
      <attribute name="decimals" a:defaultValue="0">
        <ref name="anyInteger"/>
      </attribute>
    </optional>
  </define>
  <!--
    Element:
      text      - element describing a textual datatype
    Attributes:
      size      - required positive integer indicating the maximum number of characters in the text
      default   - default value
  -->
  <define name="text">
    <element name="text">
      <ref name="attlist.text"/>
      <empty/>
    </element>
  </define>
  <define name="attlist.text" combine="interleave">
    <ref name="common"/>
    <optional>
      <attribute name="default">
        <ref name="textValue"/>
      </attribute>
    </optional>
    <attribute name="size">
      <ref name="sizeSpec"/>
    </attribute>
  </define>
  <!--
    Element:
      boolean   - element describing a logical truth value
    Attributes:
      default   - default value
  -->
  <define name="boolean">
    <element name="boolean">
      <ref name="attlist.boolean"/>
      <empty/>
    </element>
  </define>
  <define name="attlist.boolean" combine="interleave">
    <ref name="common"/>
    <optional>
      <attribute name="default">
        <ref name="booleanValue"/>
      </attribute>
    </optional>
  </define>
  <!--
    Element:
      time      -  a point in time representation.
    Attributes:
      default   - default value
    
    @todo i see duration/interval as the generic form of time, how do we deal with this?
  -->
  <define name="time">
    <element name="time">
      <ref name="attlist.time"/>
      <empty/>
    </element>
  </define>
  <define name="attlist.time" combine="interleave">
    <ref name="common"/>
    <optional>
      <attribute name="default">
        <ref name="timeValue"/>
      </attribute>
    </optional>
  </define>
  <!--
    Element:
      binary    - element describing a b binary value
    Attributes:
      size      - required positive integer indidcatin the maximum number of bytes in the binary
      default   - default value
    @todo How are we going to specify default values for binary columns?
      - inline with an encoding, say base64
      - as URI?
      - not at all (since most database wont allow it either)
  -->
  <define name="binary">
    <element name="binary">
      <ref name="attlist.binary"/>
      <empty/>
    </element>
  </define>
  <define name="attlist.binary" combine="interleave">
    <ref name="common"/>
    <attribute name="size">
      <ref name="sizeSpec"/>
    </attribute>
    <optional>
      <attribute name="default">
        <ref name="binaryValue"/>
      </attribute>
    </optional>
  </define>
  <!--
    primary element
    @todo reformulate as constraint
  -->
  <define name="primary">
    <element name="primary">
      <ref name="attlist.primary"/>
      <oneOrMore>
        <ref name="column"/>
      </oneOrMore>
    </element>
  </define>
  <define name="attlist.primary" combine="interleave">
    <ref name="common"/>
  </define>
  <!--
    index element
    @todo reformulate as constraint?
  -->
  <define name="index">
    <element name="index">
      <ref name="attlist.index"/>
      <oneOrMore>
        <ref name="column"/>
      </oneOrMore>
      <optional>
        <ref name="description"/>
      </optional>
    </element>
  </define>
  <define name="attlist.index" combine="interleave">
    <ref name="common"/>
    <optional>
      <attribute name="name"/>
    </optional>
    <optional>
      <attribute name="type" a:defaultValue="default">
        <choice>
          <value>default</value>
          <value>unique</value>
        </choice>
      </attribute>
    </optional>
  </define>
  <start>
    <choice>
      <ref name="schema"/>
    </choice>
  </start>
</grammar>
<!--
  Wishes:
  * [DONE] the 'type' attribute for the 'column' element should only designate an
  'abstract' type, not related  to the database types like TINYINT or something.
  The storage types used by different databases can be figured out by the
  generator in combination with other information supplied in the xml.
  This is basically what creole does, but the mapping they use is a set of
  types (JDBC types actually) which are still close to the actual type of the
  database. Since this code is in place, we might as well use it.
  
  Example set of more abstract types:
  - char | binary | number | boolean | date | time
  Ideally these would be children of the 'column' element so the attributes
  can be defined on them specifically (e.g. 'precision' which only makes sense for numbers and perhaps time)
  
  * [DONE] scale attribute is confusing, i'd rather use 'precision' or 'decimals' (also see previous point)
  
  * think about constraints, both on column and table level, they fit in nicely as
  children of the 'column' or 'table' elements.
  
  * [DONE] the mixed case use of 'autoIncrement' is not needed, lead
  to confusion only
  
  * [DONE] the elements 'index' and 'unique' are the same, index type='unique' would
  be better imo. Similarly, unique-column and index-column are then redundant, either
  to be replaced by just a 'index-column' element, or <column name="colname"/> to reference
  a column in the table definition.
  
  * [DONE] an element 'primary' as a grouper around the 'column' element would be nice
  Example:
  <table name="test">
      <column name="normal" type="INTEGER" size="4"/>
      <primary>
          <column name="ref_name" type="INTEGER" size="10"/>
          <column name="ref1_name" type="INTEGER" size="10"/>
      </primary>
  </table>
  
  * [IRRELEVANT] Primary keys are either automatically indexed, or should always be indexed, the
  generator can take this into account. Some databases may do this automatically, either
  explicit or implicit.
  
  * [DONE] an 'id' attribute on all tags supported.
  
  * vendor parameters *are* useful, add them back at some point, but only if
  we implement right away the support of those parameters (i.e. not only do the
  familiar mysql table type stuff, but also other parameters)
  
  * xaraya doesnt use foreign keys yet, doesnt mean we cant have support in the
  schema for it though.
  Example of how this could look:
    <table name="test">
        <column name="normal" type="INTEGER" size="4"/>
        <primary>
            <column name="ref_name" type="INTEGER" size="10"/>
            <column name="ref1_name" type="INTEGER" size="10"/>
        </primary>
        <foreign remote="other_table" ondelete="(cascade|restrict|setnull|none)" onupdate="(cascade|restrict|setnull|none)">
            <reference local="ref_name" remote="other_columns_name"/>
        </foreign>
    </table>
  ondelete means: what happens to the local record if the remote record gets deleted.
  onupdate means: what happens to the local columns if the remote columns get updated.
  If a foreign key is composite, add more <reference/> elements.
  
  * other than the precise size="14" it could be comfortable to specify 'qualitative' sizes.
  For example:
      small      64K  'c64'       'amoebe'
      medium      1M  'pda'       'fly'
      large      16M  'notebook'  'dog'
      long      256M  'laptop'    'ape'
      huge        4G  'desktop'   'human'
  where the generator translates
  this into something for the backend that fits. The second column would be
  comfortable from a developer perspective without having to know what column
  type it actually translates into, it guarantees to be capable of storing the
  specified size (at minimum)
  
  * I dont like the capital attribute values for 'type'
-->
