<?php
class xarRequest extends Object
{
    private $isObjectURL = false;
    private $isModuleURL = false;
    
    protected $url;
    protected $actionstring;
    protected $dispatched = false;
    protected $modulekey = 'module';
    protected $typekey   = 'type';
    protected $funckey   = 'func';
    protected $module    = 'base';
    protected $type      = 'user';
    protected $func      = 'main';
    protected $urlparams = array();
    
    public $defaultRequestInfo = array();

    public $entryPoint;
    public $delimiter ='/';
    public $route;
    
    function __construct($url=null)
    {
        $this->entryPoint = xarController::$entryPoint;
        $this->setURL($url);
    }

    function setURL($url=null)
    {
        if (is_array($url)) {
            // This is an array representing a traditional Xaraya URL array
            if (!empty($url['module'])) {
                $this->module = $url['module'];
                unset($url['module']);
                // Resolve if this is an alias for some other module
                $this->module = xarModAlias::resolve($this->module);
            }
            if (!empty($url['type'])) {
                $this->type = $url['type'];
                unset($url['type']);
            }
            if (!empty($url['func'])) {
                $this->func = $url['func'];
                unset($url['func']);
            }
            $this->urlparams = $url;
        } else {
            // This is a string representing a URL
            // First figure out which module is to be addressed
            if (null == $url) {
                // Try and get it from the current request path
                $url = xarServer::getCurrentURL();
                if (($url != '')
                // IIS fix
                && ($url != xarServer::getVar('SCRIPT_NAME'))) {
                    preg_match_all('|/([^/]+)|i', $url, $matches);
                    $params = $matches[1];
                    if (count($params) > 0) $this->module = $params[0];
                }
            } else {
                // Try and get it from the URL passed
                // CHECKME: test this for stability
                $url = substr($url,strlen(xarServer::getBaseURL() . $this->entryPoint . $this->delimiter));
                $tokens = explode($this->delimiter, $path);
                $this->module = array_shift($tokens);
            }
            // Resolve if this is an alias for some other module
            $this->module = xarModAlias::resolve($this->module);
            
            // Now that we have the module, resolve the rest via the appropriate controller
            $this->url= $url;
//            $this->getInfo($url);
        }
    }
    
    /**
     * Gets request info for current page or a given url.
     *
     * Example of short URL support :
     *
     * index.php/<module>/<something translated in xaruserapi.php of that module>, or
     * index.php/<module>/admin/<something translated in xaradminapi.php>
     *
     * We rely on function <module>_<type>_decode_shorturl() to translate PATH_INFO
     * into something the module can work with for the input variables.
     * On output, the short URLs are generated by <module>_<type>_encode_shorturl(),
     * that is called automatically by xarModURL().
     *
     * Short URLs are enabled/disabled globally based on a base configuration
     * setting, and can be disabled per module via its admin configuration
     *
     * TODO: evaluate and improve this, obviously :-)
     * + check security impact of people combining PATH_INFO with func/type param
     *
     * @return array requested module, type and func
     * @todo <marco> Do we need to do a preg_match on $params[1] here?
     * @todo <mikespub> you mean for upper-case Admin, or to support other funcs than user and admin someday ?
     * @todo <marco> Investigate this aliases thing before to integrate and promote it!
     */
    public function getInfo($url='')
    {
        static $currentRequestInfo = NULL;
        static $loopHole = NULL;
        if (is_array($currentRequestInfo) && empty($url)) {
            return $currentRequestInfo;
        } elseif (is_array($loopHole)) {
            // FIXME: Security checks in functions used by decode_shorturl cause infinite loops,
            //        because they request the current module too at the moment - unnecessary ?
            xarLogMessage('Avoiding loop in xarController::$request->getInfo()');
            return $loopHole;
        }
        // Get variables
        if (empty($url)) {
            xarVarFetch('module', 'regexp:/^[a-z][a-z_0-9]*$/', $modName, NULL, XARVAR_NOT_REQUIRED);
            xarVarFetch('type', "regexp:/^[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*$/:", $modType, 'user');
            xarVarFetch('func', "regexp:/^[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*$/:", $funcName, 'main');
            if (isset($modName)) $this->isModuleURL = true; 
        } else {
            $decomposed = parse_url($url);
            $params = array();
            if (isset($decomposed['query'])) {
                $pairs = explode('&', $decomposed['query']);
                try {
                    foreach($pairs as $pair) {
                        if (trim($pair) == '') continue;
                        list($key, $value) = explode('=', $pair);
                        $params[$key] = urldecode($value);
                    }
                } catch(Exception $e) {}
                sys::import('xaraya.validations');
                $regex = ValueValidations::get('regexp');
            }

            if (isset($params['module'])) {
                $isvalid =  $regex->validate($params['module'], array('/^[a-z][a-z_0-9]*$/'));
                $modName = $isvalid ? $params['module'] : null;
                $this->isModuleURL = true; 
            } else {
                $modName = null;
            }
            if (isset($params['type'])) {
                $isvalid =  $regex->validate($params['type'], array('/^[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*$/'));
                $modType = $isvalid ? $params['type'] : 'user';
            } else {
                $modType = 'user';
            }
            if (isset($params['func'])) {
                $isvalid =  $regex->validate($params['func'], array('/^[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*$/'));
                $funcName = $isvalid ? $params['func'] : 'main';
            } else {
                $funcName = 'main';
            }
        }

        if (xarController::$allowShortURLs) {
            sys::import('xaraya.mapper.dispatcher');
            $dispatcher = new xarDispatcher($this);
            $controller = $dispatcher->getController();
//            $controller->decode($this);
            if (xarMod::isAvailable($this->module) && xarModVars::get($this->module, 'enable_short_urls')) {
               $requestInfo = array($this->module,
                     $this->type,
                     $this->func) ;
                     return $requestInfo;
            }
        }

        if (!empty($modName)) {
            // Cache values into info static var
            $requestInfo = array($modName, $modType, $funcName);
        } else {
            // Check if we have an object to work with for object URLs
            xarVarFetch('object', 'regexp:/^[a-zA-Z0-9_-]+$/', $objectName, NULL, XARVAR_NOT_REQUIRED);
            if (!empty($objectName)) {
                // Check if we have a method to work with for object URLs
                xarVarFetch('method', 'regexp:/^[a-zA-Z0-9_-]+$/', $methodName, NULL, XARVAR_NOT_REQUIRED);
                // Specify 'dynamicdata' as module for xarTpl_* functions etc.
                $requestInfo = array('dynamicdata', $objectName, $methodName);
                if (empty($url)) {
                    $this->isObjectURL = true;
                }
            } else {
                // If $modName is still empty we use the default module/type/func to be loaded in that such case
                if (empty($this->defaultRequestInfo)) {
                    $this->defaultRequestInfo = array(xarModVars::get('modules', 'defaultmodule'),
                                                      xarModVars::get('modules', 'defaultmoduletype'),
                                                      xarModVars::get('modules', 'defaultmodulefunction'));
                }
                $requestInfo = $this->defaultRequestInfo;
            }
        }
        // Save the current info in case we call this function again
        if (empty($url)) $currentRequestInfo = $requestInfo;
        
        list($this->module,
             $this->type,
             $this->func) = $requestInfo;

        return $requestInfo;
    }
    
    /**
     * Check to see if this request is an object URL
     *
     * @access public
     * @return bool true if object URL, false if not
     */
    function isObjectURL() { return $this->isObjectURL; }
    function isModuleURL() { return $this->isModuleURL; }

    function getProtocol()       { return xarServer::getProtocol(); }
    function getHost()           { return xarServer::getHost(); }
    function getModuleKey()      { return $this->modulekey; }
    function getTypeKey()        { return $this->typekey; }
    function getFunctionKey()    { return $this->funckey; }
    function getModule()         { return $this->module; }
    function getType()           { return $this->type; }
    function getFunction()       { return $this->func; }
    function getActionString()   { return $this->actionstring; }
    function getURL()            { return $this->url; }
    function getURLParams()      { return $this->urlparams; }
    function getRoute()          { return $this->route; }

    function setModule($p)       { $this->module = $p; }
    function setType($p)         { $this->type = $p; }
    function setFunc($p)         { $this->func = $p; }
    function setURLParams($p)    { $this->urlparams = $p; }
    function setRoute($r)        { $this->route = $r; }
    function setActionString($p) { $this->actionstring = $p; }

    public function isDispatched()
    {
        return $this->dispatched;
    }

    public function setDispatched($flag=true)
    {
        $this->dispatched = $flag ? true : false;
        return true;
    }
}

?>