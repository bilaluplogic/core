<?php
class xarRequest extends Object
{
    private $isObjectURL = false;
    private $isModuleURL = false;
    
    protected $url;
    protected $actionstring;
    protected $dispatched = false;
    protected $modulekey = 'module';
    protected $typekey   = 'type';
    protected $funckey   = 'func';
    protected $module    = 'base';
    protected $type      = 'user';
    protected $func      = 'main';
    protected $funcargs  = array();
    protected $object    = 'objects';
    protected $method    = 'view';
    protected $urlparams = array();
    protected $route     = 'default';
    
    public $defaultRequestInfo = array();

    public $entryPoint;
    public $separator    = '&';
    
    function __construct($url=null)
    {
        $this->entryPoint = xarController::$entryPoint;
        $this->setURL($url);
    }

    function setURL($url=null)
    {
        if (is_array($url)) {
            // This is an array representing a traditional Xaraya URL array
            if (!empty($url['module'])) {
                // Resolve if this is an alias for some other module
                $this->setModule(xarModAlias::resolve($url['module']));
                unset($url['module']);
            }
            if (!empty($url['type'])) {
                $this->setType($url['type']);
                unset($url['type']);
            }
            if (!empty($url['func'])) {
                $this->setFunction($url['func']);
                unset($url['func']);
            }
            $this->setURLParams($url);
        } else {
            if (null == $url) {
                // This is a string representing a URL
                // Try and get it from the current request path
                $url = xarServer::getCurrentURL();
                $params = $_GET;
            } else {
                $params = xarController::parseQuery($url);
            }
        
            // We now have a URL. Set it.
            $this->url = $url;
            
            // Try and get the module the traditional Xaraya way
            xarVarFetch('module', 'regexp:/^[a-z][a-z_0-9]*$/', $modName, NULL, XARVAR_NOT_REQUIRED);
            
            // Else assume a form of short urls
            if (null == $modName) {
                $path = substr($url,strlen(xarServer::getBaseURL() . $this->entryPoint . xarController::$delimiter));
                $tokens = explode(xarController::$separator, $path);
                $modName = array_shift($tokens);
            }
                
            // If this is a good module name saveit (otherwise the default will beused)
            // Resolve if this is an alias for some other module
            if (!empty($modName)) $this->setModule(xarModAlias::resolve($modName));
            
            // Get the query parameters too
            // CHECKME: Module, type and func are reserved names, so remove them from the array
            unset($params['module']);
            unset($params['type']);
            unset($params['func']);
            $this->setURLParams($params);
            
            // At this point the request has assembled the module it belongs to and any query parameters.
            // What is still to be defined by routing are the type and function/function arguments.            
        }
    }
    
    /**
     * Gets request info for current page or a given url.
     *
     * Example of short URL support :
     *
     * index.php/<module>/<something translated in xaruserapi.php of that module>, or
     * index.php/<module>/admin/<something translated in xaradminapi.php>
     *
     * We rely on function <module>_<type>_decode_shorturl() to translate PATH_INFO
     * into something the module can work with for the input variables.
     * On output, the short URLs are generated by <module>_<type>_encode_shorturl(),
     * that is called automatically by xarModURL().
     *
     * Short URLs are enabled/disabled globally based on a base configuration
     * setting, and can be disabled per module via its admin configuration
     *
     * TODO: evaluate and improve this, obviously :-)
     * + check security impact of people combining PATH_INFO with func/type param
     *
     * @return array requested module, type and func
     * @todo <marco> Do we need to do a preg_match on $params[1] here?
     * @todo <mikespub> you mean for upper-case Admin, or to support other funcs than user and admin someday ?
     * @todo <marco> Investigate this aliases thing before to integrate and promote it!
     */
    public function getInfo($url='')
    {
        
        static $currentRequestInfo = NULL;
        static $loopHole = NULL;
        if (is_array($currentRequestInfo) && empty($url)) {
            return $currentRequestInfo;
        } elseif (is_array($loopHole)) {
            // FIXME: Security checks in functions used by decode_shorturl cause infinite loops,
            //        because they request the current module too at the moment - unnecessary ?
            xarLogMessage('Avoiding loop in xarController::$request->getInfo()');
            return $loopHole;
        }
        // Get variables
        if (empty($url)) {
            xarVarFetch('module', 'regexp:/^[a-z][a-z_0-9]*$/', $modName, NULL, XARVAR_NOT_REQUIRED);
            xarVarFetch('type', "regexp:/^[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*$/:", $modType, 'user');
            xarVarFetch('func', "regexp:/^[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*$/:", $funcName, 'main');
            if (isset($modName)) $this->isModuleURL = true; 
        } else {
            $params = xarController::parseQuery($url);
            if (!empty($params)) {
                sys::import('xaraya.validations');
                $regex = ValueValidations::get('regexp');
            }
            if (isset($params['module'])) {
                $isvalid =  $regex->validate($params['module'], array('/^[a-z][a-z_0-9]*$/'));
                $modName = $isvalid ? $params['module'] : null;
                $this->isModuleURL = true; 
            } else {
                $modName = null;
            }
            if (isset($params['type'])) {
                $isvalid =  $regex->validate($params['type'], array('/^[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*$/'));
                $modType = $isvalid ? $params['type'] : 'user';
            } else {
                $modType = 'user';
            }
            if (isset($params['func'])) {
                $isvalid =  $regex->validate($params['func'], array('/^[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*$/'));
                $funcName = $isvalid ? $params['func'] : 'main';
            } else {
                $funcName = 'main';
            }
        }

        if (!empty($modName)) {
            // Cache values into info static var
            $requestInfo = array($modName, $modType, $funcName);
        } else {
            // Check if we have an object to work with for object URLs
            xarVarFetch('object', 'regexp:/^[a-zA-Z0-9_-]+$/', $objectName, NULL, XARVAR_NOT_REQUIRED);
            if (!empty($objectName)) {
                // Check if we have a method to work with for object URLs
                xarVarFetch('method', 'regexp:/^[a-zA-Z0-9_-]+$/', $methodName, NULL, XARVAR_NOT_REQUIRED);
                // Specify 'dynamicdata' as module for xarTpl_* functions etc.
                $requestInfo = array('dynamicdata', $objectName, $methodName);
                if (empty($url)) {
                    $this->isObjectURL = true;
                }
            } else {
                // If $modName is still empty we use the default module/type/func to be loaded in that such case
                if (empty($this->defaultRequestInfo)) {
                    $this->defaultRequestInfo = array(xarModVars::get('modules', 'defaultmodule'),
                                                      xarModVars::get('modules', 'defaultmoduletype'),
                                                      xarModVars::get('modules', 'defaultmodulefunction'));
                }
                $requestInfo = $this->defaultRequestInfo;
            }
        }
        // Save the current info in case we call this function again
        if (empty($url)) $currentRequestInfo = $requestInfo;
        
        list($this->module,
             $this->type,
             $this->func) = $requestInfo;

        return $requestInfo;
    }
    
    /**
     * Check to see if this request is an object URL
     *
     * @access public
     * @return bool true if object URL, false if not
     */
    function isObjectURL() { return $this->isObjectURL; }
    function isModuleURL() { return $this->isModuleURL; }

    function getProtocol()       { return xarServer::getProtocol(); }
    function getHost()           { return xarServer::getHost(); }
    function getModuleKey()      { return $this->modulekey; }
    function getTypeKey()        { return $this->typekey; }
    function getFunctionKey()    { return $this->funckey; }
    function getModule()         { return $this->module; }
    function getType()           { return $this->type; }
    function getFunction()       { return $this->func; }
    function getObject()         { return $this->object; }
    function getMethod()         { return $this->method; }
    function getActionString()   { return $this->actionstring; }
    function getFunctionArgs()   { return $this->funcargs; }
    function getURL()            { return $this->url; }
    function getURLParams()      { return $this->urlparams; }
    function getRoute()          { return $this->route; }

    function setModule($p)               { $this->module = $p; }
    function setType($p)                 { $this->type = $p; }
    function setFunction($p)             { $this->func = $p; }
    function setObject($p)               { $this->object = $p; }
    function setMethod($p)               { $this->method = $p; }
    function setURLParams($p=array())    { $this->urlparams = $p; }
    function setRoute($r)                { $this->route = $r; }
    function setActionString($p)         { $this->actionstring = $p; }
    function setFunctionArgs($p=array()) { $this->funcargs = $p; }

    public function isDispatched()
    {
        return $this->dispatched;
    }

    public function setDispatched($flag=true)
    {
        $this->dispatched = $flag ? true : false;
        return true;
    }
}

?>