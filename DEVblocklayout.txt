Blocklayout version 2
=====================

Other places of information:
    * http://wiki.xaraya.com/index.php?title=Blocklayout_Version_2
    * RFC-0054 (which should receive most of the specs written here)

Concept change:
---------------

Instead of grabbing each character in the input and parsing out the templates
we implement a 'pass through, unless' type XSL transformation. This means that
each tag we want to do something special to the output has one or more XSL
templates which match it in context and transform the input to the desired
output. The specifics of the transformation are determined by context and the
value signature of the attributes. This whole process is XML based, from
beginning to (just before) the end. All rules XML implies, apply to this
process too.


Issues
------

- [DONE] how to cross the border? i.e. how do parameters from the module
  get passed into the xslt processor (see parameter section below and
  xsltransformer.php )
- [STARTED] how do we create a suiteable test suite (make a compilation of the
  core templates?) Testsuite in theme XClassic
  modules/base/user-main-compilertest.xt]
- can we make a stub inserting some random values for the template vars,
  so we can compare somehow
- [DONE] is merging with other output namespaces just a question of copying
  output (xhtml in our case) (A: yes)
- how do we handle #$var# constructs?
  * ideally i want to handle it through separation of the template in two
    sections, data and presentation, both in the xml domain:
  * one way of doing that is to make #$var# ~ &var; but this is a pain to
    handle for XSLT, since it assumes entities to be known/declared at
    transform time, which is clearly not the case
  * another separation mechanism is to create a "data" section (xml
    fragment) to go with the template: like
    <tpldata>
      <vars>
        <var name="var">value</var>
          ...
      </vars>
    </tpldata>

    or something like that, generated dynamically, From then on we can
    reach each var by using XPath expressions like

      /tpldata/vars/var[@name='varname']

    which sounds sort of attractive because it is almost exactly like the
    array stuff, but then XML compliant. It also means that we would need
    to translate each and every template to this syntax.
- the xarBLCompiler.php does some processing here and there, which of
  these need to stay in php, which of them can be done by xsl? We can take
  them on a case by case basis, since php functions can be called
  reasonably easy from within the transform, but each case is a weakness
  in portability so we try to avoid it.
- it really doesnt make sense anymore now to go through the hoops of
  registering custom tags etc. One xsl snippet for a custom tag,
  generating the right code is a lot easier. Note: this would also
  invalidate the whole GUI where tags are shown on screen and can be
  manually entered into the database, which is of questionable use anyway,
  apart from a debugging perspective.
- go over all xar: tags attributes and decide how resolving should be
  handled, dont add a resolvement unless you have a usecase.
- our # delimiter conflicts with the use of generic entities in not-so-rare
  cases.

  Example 1:

   `#$modinfo['adminurltitle']#&#160;#$modinfo['displayname']#
     |_______first expr______| ^ |__| |_________text________|\- lonely #
                               |   \- second expr
                               |- single & 'text'`

  Example 2:

    `##$variable##`

    Could be:

        [empty expression][text: $variable][empty expression]  OR
        [text: #][content of $variable][text: #]

    depending on how it's looked upon

  Example 3:

    Inline CSS:

        <style>
        #someID  { color: red; }
        #someID2 { color: blue;}
        </style>

    As seen through compiler eyes: [expression: 'someID { color: ref; }\n'][text: 'someID2 { color: blue;}']
- [DONE]the construct <div style="clear: left|right|both"><div> appears to render improperly.
    See:
        - http://www.stylusstudio.com/xsllist/200209/post10350.html
        - mtn rev: 6143d31238f3aaa6309a390f16fca034b9d1cda2
- [DONE]javascript construct:
    <script type="text/javascript">Calendar.setup({#$js_options#});</script>
  (from the dhtml calendar at dynarch.com) appears to render improperly.
    This turned out to be a <script/> empty tag issue, as above with the div.

- we are now in a postion to create a DTD, let's do so.
- instead of organising by tag, it seems to make more sense to organize by
  'group' (flow, comment, blocks etc.) as those tags often interrelate and use
  similar constructs in their handlers.
- 'Friendliness' options:
    * if a variable is not set, boom! Why not wrap it with an isset() for
      example? Or give it a predefined !!UNKOWN!! value?
    * can we separate the parse and render stages? during parse errors,
      the rendering bombs out in ugliness, where it possibly doesnt need to
      do that.
- put the new tags locations into the dirlayout proposal
- [DONE] we now add a root tag to module templates artificially. This leads to a
  number of things we can not do now:
    * as we 'pre-read' the templatefile to add this tag, the filename of the
    template gets lost when an exception is raised. We really should add the
    root tag to the templates themselves. (this can be automated)
    * individual templates are not well-formed (interoperability)
  (all core templates have had their root tags added in)
- we omit the xml declaration now, because it doesnt work, but i dont remember
  why anymore. Either make it work (preferably) or document why it can't.
  This has to do with <?xml conflicting with <?php when producing code.
- declare xml specials somewhere:
    - <!ATTLIST element xml:space (default|preserve) 'preserve'>
        for elements which may choose
    - <!ATTLIST element xml:space (preserve) #FIXED 'preserve'>
        for elements which should have space preserving.

Refactoring needs
=================

While fixing the errors along the way, some redesign issues have surfaced.

* generating XML can confuse HTML renderers. The empty div and script issues
  are not really compiler/blocklayout issues, but many browsers just dont
  deal well with empty tags. There is a solution (see xar2php.xsl) but it really
  should only be deployed when the output type *is* actually (X)HTML. We can
  deploy the fix for all XML varieties, as it doesnt change semantics, but its
  not very nice. We plan to separate the *format* in the process anyway, so lets
  keep this in mind when we actually will.
* We generate a xml + php document from (now well formed) xml, thus losing
  some of our power (the compiled templates are not necessarily well formed)
  This means we get into trouble with the DOCTYPE generation, and using the
  xsl:output attributes for this, which would be the correct way, will lead to
  some changes in the xar: language, as we can not set the dtd in the blocklayout
  tag anymore then. (which makes sense, it was an emergency exit anyway). Nevertheless,
  that means we have to go to the drawing board on how to do this.
* language changes (see section further on)


Language change proposals:
==========================

This section lists 'almost RFC ready' parts on language changes which are a
bit bigger.

Multilanguage constructs in Blocklayout
---------------------------------------

This change proposal consists of the following parts:
    1. xar:mlvar deprecation (removal)
    2. xar:mlstring deprecation (possibly removal)
    3. change of MLS notion in general in templates 'translate, unless'
    4. removal of the special MLS placeholders from the template space

The concept of translating textnodes upto now has been:

    "mark specific snippets of text by surrounding them with xar:mlstring tag
    to signal translateable text. If the text contained variable part, mark
    these with #(1) placeholders, one for each variable piece of content."

The problems this creates are:
    1. verbosity, xar:mlstring around every piece of text.
    2. when variable parts are needed, the xar:ml/xar:mlvar construct creates
    more verbosity, while ruining the context.
    3. nightmare to translate a chunk which contains, say, links without
    reverting to chopping everything up into little pieces

To address these problems I propose the following:

    1. The translation concept becomes:
        "translation is enabled by default on all textnodes unless a (global or
         local) setting is set to not translate a node."
    2. On a per-node (which can be whole tree of nodes) basis, nodes can be
    'pinned' to a certain language through the use of the 'xml:lang' attribute
    value as per:
    [Tags for the Identification of Languages](http://www.ietf.org/rfc/rfc3066.txt)
    meaning the content of those tags is not translated into other languages
    than the signalled one.
    3. A mechanism will be provided to signal the MLS system to treat a node(-set)
    as a unit with respect to translation.
    4. the mls should be a 'module' which can be disabled entirely from the compile
    phase, meaning that if the taglib for MLS is not loaded into the compiler
    everything should function normally, except for the translateability.

The easiest way to show the consequences of the above changes is to list
the 'old vs new' for as many examples we can think of:

Plain translation:
------------------

Old:
    <p><xar:mlstring>A paragraph which should be translated</xar:mlstring></p>
New:
    <p>A paragraph which should be translated</p>

Pinning content:
----------------

Old:
    <p>This to stay in English</p>
    <p>This color is red</p>
    <p>This colour is yellow</p>
    <p>Deze paragraaf is in het Nederlands en moet zo blijven</p>
New:
    <p xml:lang="en">This to stay in English</p>
    <p xml:lang="en-US">This color is red</p>
    <p xml:lang="en-GB">This colour is yellow</p>
    <p xml:lang="nl">Deze paragraaf is in het Nederlands en moet zo blijven</p>
NOTE:
    An interesting template will be the template of the Language dropdown
    property, which may contain localized textnodes of every country listed
    in its own language. Use this property as a testcase!!!

Content with variable substitutions, single level, single namespace
-------------------------------------------------------------------

Old:
    <p>
      <xar:ml>
        <xar:mlstring>Some text with #(1) and #(2) and #(3).</xar:mlstring>
        <xar:mlvar>$first</xar:mlvar>
        <xar:mlvar>#$second#</xar:mlvar>
        <xar:mlvar><xar:var name="third" /></xar:mlvar>
      </xar:ml>
      Lorem ipsum dolor sit amet, consectetur adipisicing elit....
      ...
      ...
      ... est laborum.
    </p>
New:
    <p>
      <xar:ml>
        Some text with <xar:var name="first"/> and <xar:var name="second"/> or <xar:var name="third"/>.
      </xar:ml>
      Lorem ipsum dolor sit amet, consectetur adipisicing elit....
      ...
      ...
      ... est laborum.
    </p>
NOTE: Interpret xar:ml as "register this specifically for translation". The
ending </xar:ml> can be placed anywhere in the <p/>, depending on what
should be registered. If it were to be omitted, the whole <p> textnode would
be registered as the unit to translate.

Examples:
    <p>
      <xar:ml>
        Some <a href="http://example.org">Linked <xar:var name="first"/> text</a> with <xar:var name="second"/>
      </xar:ml>
    </p>
is the same as:
    <p>
        Some Linked <xar:var name="first"/> text with <xar:var name="first"/> <!-- One unit of translation -->
    </p>
THROUGH THE EYES OF TRANSLATION!, while:
    <p>
        Some <a href="http://example.org">Linked <xar:var name="first"/> text</a> with <xar:var name="second"/>
    </p>
is the same as:
    <p>
        <xar:ml>Some </xar:ml>
        <a href="http://example.org">Linked <xar:var name="first"/> text</a>  <!-- 3 units of translation -->
        <xar:ml> with <xar:var name="first"/></xar:ml>
    </p>
THROUGH THE EYES OF TRANSLATION!

Implementation:
---------------
In template:
  <p>
    Some <a href="http://example.org">Linked <xar:var name="first"/> text</a> with <xar:var name="second"/>
  </p>
Should pass to MLS for translation:
  1. '␣Some␣'             -- should both front and end have 1 spacer?
  2. 'Linked␣#(1)␣text'
  3. '␣with␣#(1)␣'        -- should the end have the spacer?
In template:
  <p>
    <xar:ml>
      Some <a href="http://example.org">Linked <xar:var name="first"/> text</a> with <xar:var name="second"/>
    </xar:ml>
  </p>
Should pass to MLS for translation:
  '␣Some␣Linked␣#(1)␣text␣with␣#(2)␣'       -- same questions as above


Expression resolving
====================

Before going into the issues at hand, a couple of general statements on
templating engines, or templating languages.

There are a lot of them! By far, the most are sloppy, ill designed, slow or
just grew out of a hack. A few of them are real gems to use though and well
thought out. Without exception, they all have some sort of mechanism to
control flow, set and use variables etc. in an extension to their 'hosting
language' Sometime built as 'escape mechanisms' into the programming language
in which the template engine was written, sometimes defining its own
mini-language.

To further narrow the templating languages we consider interesting; the XML
native ones. By this, I mean templating languages which, considered as such,
are a valid XML document. There are other means to construct XML 'based'
templating engines, meaning they look like XML, but dont use much more than
some tags to describe the templating constructs and escape to other mechanisms
for defining structures or operations. We wont consider those here.

So, what techniques do we have to make up a native XML templating language
with sufficient power?

Technique 1. namespaced taglib to define operations. : <xar:sometag />
----------------------------------------------------------------------

The obvious one, is to define a tag lib in a namespace specifically for the
templating domain. Blocklayout is no exception. We define the xar: namespace
as ours and all tags in that namespace are handled by BL.

What you can do with a tag is pretty limited. It has a name, is empty or open,
and may define attributes which have values. Combining all of those leads to
lots of different options, but it's all still static, so that is why most TPLs
come up with an expression language to bring variables into the picture. More
on that later on. Xaraya uses this techniques extensively, but often in inconsistent
ways, or even invalid ways.

Technique 2: namespaced attribute lib to extend sibling taglibs. : <div xar:extra="test"/>
------------------------------------------------------------------------------------------

What only a handful template engines use is the namespaced attribute
technique. Similarly to the namespaced tags, you can employ namespaced attributes
to be handled by your engine. BL doesnt  use this technique yet either. The
key addition this brings to the table is that you can hook your namespace into
others. Say you combine html and blocklayout in a template a div tag, belonging
to the html (default) namespace can be (legally) extended by;

    <div style="border:thin" xar:extra="somevalue">
        <img src="myPicture.png" />
    </div>

Assuming the namespaces are properly tagged onto the document, this is perfectly
valid XML. This allows a template engine to extend another namespace with
extended behaviour. Still, the same XML rules apply and all information is
still static.

The above is really what XML has to offer. Through clever combinations of both
techniques it may seem there is more, but there really isn't :-)
Defining multiple namespaces (one for structure, one for data for example) and
defining ways in which they should interoperate is one such method which seems
to add additional things.

Technique 3: define dynamic behaviour through an expression language
--------------------------------------------------------------------

Here's where the problem starts. XML, as such, unless implemented explicitly
in one of the two previous techniques doesnt define dynamic behaviour in itself.
There is however a staggering amount of ways to give it one:

    1. XPath expression language to point to XML things and execute some functions on them
    2. Extensions of XPath like XPointer and XLink for example
    3. XQuery to search into XML
    4. An event model layered into what is known as a DOM (into 3 levels) which
    introduces an indirect way to manipulate XML documents by modelling them as
    an hierarchical object. It's not entirely clear where the OnEvent like
    attributes come into play. (that is, to which doctype they actually belong)
    5. Choose a specific doctype like XHTML and you get another set of dynamics, specific to what
    the dialect was designed for (xul+javascript for example)
    6. Databinding specifications like XForms and RDF

and last but not least the custom expression languages which every template
engine i ever came across has.

Looking at the future for Blocklayout, technique 1 will continue to dominate
how people perceive the language. One thing which sets apart BL from many
other template languages, is that most of its operations are encoded in the
tag namespace and not as a specific expression language. The possibilities of
using namespaced attributes we havent begun to explore yet. A weakness which
BL has had from the beginning, perhaps due to the intial focus to encode the
operations as XML tags, is the definition of its expression language, or the
lack thereof.

In short, we escape to PHP through a # character and try to evaluate and pass
back whatever the PHP delivers in the expression. This has worked reasonably
well because we compile the BL tags to PHP and it makes perfect sense to
inject the expressions in PHP too.

We allow expressions in pretty much an ad-hoc set of places. They are almost
always allowed in XML text nodes, sometimes allowed in attributes, but not
everywhere and there are also two ways of interpreting them. Some tags require
a direct-PHP like syntax (like the xar:data* tags), others adhere to the #..#
enclosed syntax while quite a few of them dont support expressions at all. All
of these grew on us over time.

Currently, as we are redefining/reviewing blocklayout for version 2 we see the
at least following problems (top 10):

    1. the absence of a strong definition of what an expression is makes it
    hard (this is perhaps an open door, its the cause of all the other
    problems obviously) to write a good component which handles them
    consistently.

    2. because they are used in at least 3 different ways, its hard to stay
    compatible AND consistent

    3. We have a tendency to solve things 'the PHP way' with xar:set as our
    hammer.

    4. Specifying and resolving expressions in attributes is problematic, we
    mix and match the semantics of 'referencing' something and 'using the
    value' of something. The 'name' type attributes being the most prominent
    example.

    5. Within the engine there is more than one need for 'expression like'
    constructs. Assigning things, Multilanguage placeholders and Value
    expressions are 3 examples of different things we try to push into one
    syntax. (not necessarily bad, but harder)

    6. The binding with our host language PHP causes some trouble, because php
    is somewhat similar, but not quite like an XML processing instruction. <?
    <?php <script type="application/php" are 3 possible ways to signal a php
    block, all of which are invalid in an attribute in XML, and can never be
    used directly. Also <? conflicts with <?xml in some situations.

    7. Over time we have defined a number of mechanisms to specify expressions,
    implicitly assuming some wished for operation. Example: #$varname# in
    textnodes is automatically assuming 'echo $varname', i.e. outputting it
    where as attribute="#$varname#" does not. (again, not necessarily bad, but
    more an accident than design)

    8. #(1) is a placeholder for translations in a very specific situation to
    be replaced by a variable. When there are more of those placeholders, it
    becomes unclear, or at least more complicated to separate the placeholders
    from expressions and they can not be used together in most cases.
    (example: "For #(1),&#160; there are ##$count# elements" is ambiguous in
    what this should mean, a mix of #(1), &#160;, # and #$count# in one textnode)

    9. Related to 8. The choice of the # character as our delimiter may be
    unfortunate, because the one escape mechanism XML has for specifiying
    characters in an indirect, but portable, way are numeric entities which also
    happen to use the # character, further complicating the matter. ( &#160;
    is an example)

    10. The combination of these points leads to the necessity of pre and
    postprocessing the templates in less than elegant ways to ensure we can
    process the templates properly. The mere fact of pre- and postprocessing
    is pretty normal, but we often cant handle an issue on one side (that is,
    either in the transform stage or in pre or post handling) but have to do
    it on both sides. Above all, this creates complexity and maintenance
    problems.